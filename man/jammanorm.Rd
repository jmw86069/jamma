% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jamma-norm.R
\name{jammanorm}
\alias{jammanorm}
\title{Normalize data using MA-plot logic}
\usage{
jammanorm(
  x,
  controlGenes = NULL,
  minimum_mean = 0,
  controlSamples = NULL,
  centerGroups = NULL,
  useMedian = TRUE,
  useMean = NULL,
  noise_floor = -Inf,
  noise_floor_value = noise_floor,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{x}{\code{numeric} matrix with expression data suitable for use
by \code{jammaplot()}. Gene expression data is typically transformed
using \code{log2(1+x)} to represent reasonably normal distribution.}

\item{minimum_mean}{\code{numeric} value used to filter \code{controlGenes},
a control gene must have at least this level of expression to
be included in the normalization, where the expression is
determined by the mean or median value analogous to the x-axis
value in MA-plots.}

\item{controlSamples}{\code{character} vector of \code{colnames(x)} passed
to \code{centerGeneData()} which defines the control samples during
the data centering step.
By default, and the most common practice, MA-plots are
calculated across all samples, which effectively uses all
\code{colnames(x)} as \code{controlSamples}.
However, it is quite useful sometimes to provide a subset of
samples especially if there are known quality samples, to which
new samples of unknown quality are being compared.}

\item{centerGroups}{\code{character} vector of groups passed to
\code{jamma::centerGeneData()} which determines how data is centered.
Each group is centered independently, to enable visual
comparisons within each relevant centering group.
It is useful to center within batches or within
subsets of samples that are not intended to be compared to
one another.
Another useful alternative is to center by each sample
group in order to view the variability among group
replicates, which should be much lower than variability across
sample groups. See \code{centerGeneData()} for more specific examples.}

\item{useMedian}{\code{logical} indicates whether to center data
using the \code{median} value, where \code{useMedian=FALSE} by default.
For consistency, this argument is preferred to \code{useMean} which
is deprecated and will be removed in future. The median is
preferred in cases where outliers should not influence the
centering. The mean is preferred in cases where the data
should visualize data consistent with downstream parametric
statistical analysis. When a particular sample
is a technical outlier, one option is to define
\code{controlSamples} to exclude the outlier sample(s), so
the data centering will be applied using the non-outlier
samples as reference.}

\item{useMean}{\code{logical} (deprecated), use \code{useMean}. This argument
indicates whether to center data using the \code{mean} value.
When \code{useMean=NULL} the argument \code{useMedian} is preferred.
For backward compatibility, when \code{useMean} is not \code{NULL},
then \code{useMedian} is defined by \code{useMedian <- !useMean}.}

\item{noise_floor, noise_floor_value}{\code{numeric} values passed
to \code{jammacalc()}. The \code{noise_floor} is the value below which
a floor is applied. The floor sets all values below this floor
to \code{noise_floor_value}. For example, one could apply \code{noise_floor=0}
and \code{noise_floor_value=NA} which would change any value below 0
to \code{NA}.}

\item{verbose}{logical indicating whether to print verbose output.}

\item{...}{additional parameters sent to downstream functions,
\code{\link{jamba::plotSmoothScatter}}, \code{\link{centerGeneData}}.}
}
\value{
\code{numeric} \code{matrix} whose columns have been normalized,
with the following named \code{attributes}:
\itemize{
\item \code{"nf"} numeric vector of normalization factors;
\item \code{"hk"} a \code{character} vector of controlGenes for each sample;
\item \code{"hk_count"} the \code{integer} number of controlGenes for each sample.
}
}
\description{
Normalize data using MA-plot logic
}
\details{
This function normalizes data using an approach analogous
to data viewed in MA-plots. Normalization is applied by shifting
data along the y-axis so the mean (or median) expression among
control genes is zero, indicated on an MA-plot as y=0.

\strong{Note:} This method should be performed only after reviewing the MA-plots,
to ensure the assumptions are met. Similarly, data can also be
viewed in MA-plots after normalization to confirm and review the
effect of normalization.

It is useful to run \code{jammaplot()} data after \code{jammanorm()}
to visualize the effect of this normalization. If data is not
centered at y=0, the parameters should be adjusted.
\subsection{Assumptions}{

This method effectively reinforces the assumption that the mean log fold
change for control genes is expected to be zero. When \code{useMedian=TRUE}
it reinforces the assumption that the log fold change for the
majority of control genes should be zero.

Therefore, the assumptions may be summarized as follows:
\itemize{
\item The principle assumption is that the set of \code{controlGenes},
whose mean expression is at or above the \code{minimum_mean} value,
are unchanged within the respective \code{centerGroups}. For typical
whole genome transcript microarray and RNA-seq experiments,
this assumption is typically valid when using \code{useMedian=TRUE}.
For experiments with specific reference genes, or housekeeper
genes, this assumption may only be true for those specific genes.
\item The data signal is assumed to be a roughly linear representation
of the relative abundance of each measured entity, which is usually
true for log-transformed microarray intensity, or log-transformed
RNA-seq read counts. For QPCR or TaqMan, this assumption is valid
for the direct CT cycle threshold values, or after log-transformation
of the exponentiated CT values, for example 2^(40-CT).
All that said, a straightforward way to visualize this assumption
is with MA-plots, to confirm that signal is horizontal across
the full signal range - either for the majority of all genes,
or for the specific \code{controlGenes} used for normalization.
\item The variability among control genes should not be more than twice
the median absolute deviation across other samples within the
relevant \code{centerGroups}. Effectively this assumption means the
control genes on the MA-plot should not show wide spread along the
y-axis.
}

In cases where some samples show non-horizontal signal across the
MA-plot, the data is not conforming to a consistent and proportional
signal across the response range of the experiment. In effect, it
means signal is being compressed, or expanded along the response
as compared to other samples in the same \code{centerGroups}. In this
scenario, the best normalization method may be
\code{limma::normalizeQuantiles()}, \code{limma::normalizeCyclicLoess()},
or \code{vsn::vsn()}. These methods adjust the distribution of signal
to enforce consistency across samples.

In general, the signal distribution itself should not be adjusted
unless necessary, in order to retain as much information from the
underlying technology as possible. This method \code{jammanorm()} is
intended to apply linear normalization, which effectively shifts
the entire signal for a sample up or down relative to other samples.

This scenario is effective for technologies such as QPCR, TaqMan,
Nanostring counts, and RNA-seq counts or RNA-seq pseudocounts.

When the MA-plot demonstrates non-horizontal
signal, it is most often the result one or both of these influences:
\enumerate{
\item batch effect, imposed either by different upstream sample
processing steps among the samples being tested, or
\item platform technology that tends to produce relative signal strength
but not absolute quantitative signal, commonly seen with
microarray hybridization technologies such as Affymetrix, Illumina,
Agilent, SomaLogic, or Myriad RBM.
}

Note that any upstream sample amplification technique may also impose
non-linear effects on the molecules being measured.

One method to test for a batch effect is to define \code{centerGroups}
to include batch, so the data will be centered for each batch
independently. If this centering resolves the non-horizontal
signal, then batch is very likely to be a component to be modeled
in the experiment. See \code{limma::removeBatchEffect()}. The batch effect
adjustment by  \code{limma::removeBatchEffect()} and \code{sva::ComBat()}
almost exactly subtract the batch component from the signal.

That said, it may or may not be ideal to apply batch adjustment
prior to running downstream statistical tests, as opposed to
including batch as a covariate term in the statistical
model used for testing, example when using \code{DESeq2}.
The main benefit of applying batch adjustment at this step is to
visualize data downstream consistent with the method used by
those statistical tests, or when running a clustering technique
that does not have the capability of applying appropriate
batch effect modeling.
}

\subsection{About the normalization}{

This normalization is a "linear normalization" in that it uniformly
shifts data up or down relative to other samples, without
modifying the relative distribution of signal. It is very similar
to housekeeper normalization, geometric mean normalization, and
global signal scaling, which are all also "linear normalization"
methods. An example of non-linear normalization is quantile or
VSN normalization.

The control genes can be defined upfront with \code{controlGenes},
which can be housekeeper genes, or a custom subset of genes.
The \code{controlGenes} are filtered to require the mean or median
expression at or above \code{minimum_mean} in order to be used
during normalization.

The \code{minimum_mean} threshold is useful and important to match
the variability seen in the MA-plots. For example data below
a certain x-axis value may have very high variability, and
should usually not be used for normalization.

When the MA-plot after normalization does not show signal centered
at y=0, the most common and effective adjustment is to apply
\code{minimum_mean} to require \code{controGenes} to have expression
at or above this threshold. The next most effective option is
\code{useMedian=TRUE} which will center the majority of genes at
y=0 instead of the overall mean at y=0.
}

\subsection{Comparison to geometric mean normalization}{

The end result is very similar to other housekeeper normalization
methods which typically define normalization factors by
calculating the geometric mean of log-transformed housekeeper
gene abundances. Such approaches usually work in part because
higher expressed housekeeper genes usually have lower variability,
which keeps the influence on geometric mean reasonably consistent
across a broad range of expression. That said, genes with higher
expression have more influence on the geometric mean than genes
with much lower expression.

However, the strategy with \code{jammanorm()} is to assert that
the mean difference from average expression for the \code{controlGenes}
should be equal to zero. The effect is applied evenly across
control genes by evaluating the mean or median difference from y=0
for each sample.
}

\subsection{Noise threshold}{

Note that some platform technologies generate a noise threshold,
below which data may be skewed up or down relative to other samples.
It is recommended to ignore this type of skew below the threshold
when determining whether data is horizontal on MA-plots.

For example Nanostring data includes a series of positive and
negative control probes, and a suitable noise threshold is either
the midpoint between the lowest positive and highest negative probe,
or the lowest positive probe. When this noise threshold is applied,
data above the noise threshold is typically horizontal, although
data below the threshold may be skewed up or down depending upon
the effective input RNA concentration.
}
}
\seealso{
Other jam matrix functions: 
\code{\link{centerGeneData}()},
\code{\link{jammacalc}()}
}
\concept{jam matrix functions}
